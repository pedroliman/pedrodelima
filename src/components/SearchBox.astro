---
// SearchBox component for searching publications and tags
---

<div class="search-box-container">
  <form class="relative" onsubmit="return false;">
    <input
      type="text"
      id="search-input"
      placeholder="Search publications or topics..."
      class="w-full h-10 px-4 pr-10 text-sm bg-white/90 border border-gray-300 rounded-lg focus:outline-none focus:bg-white focus:border-gray-400 focus:ring-2 focus:ring-blue-500/20 transition-all"
      autocomplete="off"
    />
    <button
      id="search-button"
      class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 transition-colors"
      type="submit"
    >
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg>
    </button>
  </form>

  <!-- Search Results Dropdown -->
  <div
    id="search-results"
    class="absolute z-50 w-full mt-2 bg-white border border-gray-200 rounded-lg shadow-xl hidden"
  >
    <div id="search-results-content">
      <!-- Results will be populated by JavaScript -->
    </div>
  </div>
</div>

<script>
  let publications = [];
  let allTags = new Set();

  // Simple slugify function (copied from utils)
  function slugify(input) {
    if (!input) return '';
    var slug = input.toLowerCase().trim();
    slug = slug.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    slug = slug.replace(/[^a-z0-9\s-]/g, ' ').trim();
    slug = slug.replace(/[\s-]+/g, '-');
    return slug;
  }

  // Load publications data on page load
  async function loadData() {
    try {
      console.log('Loading publications data...');
      const response = await fetch('/api/publications.json');
      console.log('Response status:', response.status);
      if (response.ok) {
        publications = await response.json();
        console.log('Loaded publications:', publications.length);
        // Collect all unique tags
        publications.forEach(pub => {
          if (pub.tags) {
            pub.tags.forEach(tag => allTags.add(tag));
          }
        });
        console.log('Loaded tags:', allTags.size);
      } else {
        console.error('Failed to load publications, status:', response.status);
        // Fallback: try to continue without data
        publications = [];
      }
    } catch (error) {
      console.error('Failed to load publications:', error);
      // Fallback: try to continue without data
      publications = [];
    }
  }

  // Search function
  function searchContent(query) {
    if (!query || query.length < 2) {
      return { publications: [], tags: [] };
    }

    const queryLower = query.toLowerCase();
    const matchedPublications = [];
    const matchedTags = [];

    // Search publications
    publications.forEach(pub => {
      let score = 0;
      let reasons = [];

      // Title match (highest priority)
      if (pub.title.toLowerCase().includes(queryLower)) {
        score += 10;
        reasons.push('title');
      }

      // Abstract match
      if (pub.abstract && pub.abstract.toLowerCase().includes(queryLower)) {
        score += 5;
        reasons.push('abstract');
      }

      // Journal match
      if (pub.journal.toLowerCase().includes(queryLower)) {
        score += 3;
        reasons.push('journal');
      }

      // Authors match
      if (pub.authors.toLowerCase().includes(queryLower)) {
        score += 2;
        reasons.push('authors');
      }

      // Tags match
      if (pub.tags) {
        pub.tags.forEach(tag => {
          if (tag.toLowerCase().includes(queryLower)) {
            score += 4;
            reasons.push('tags');
          }
        });
      }

      if (score > 0) {
        matchedPublications.push({ ...pub, searchScore: score, matchReasons: reasons });
      }
    });

    // Search tags
    Array.from(allTags).forEach(tag => {
      if (tag.toLowerCase().includes(queryLower)) {
        const tagPublicationCount = publications.filter(pub => 
          pub.tags && pub.tags.includes(tag)
        ).length;
        matchedTags.push({ tag, publicationCount: tagPublicationCount });
      }
    });

    // Sort publications by search score (descending)
    matchedPublications.sort((a, b) => b.searchScore - a.searchScore);

    // Sort tags by publication count (descending)
    matchedTags.sort((a, b) => b.publicationCount - a.publicationCount);

    return {
      publications: matchedPublications.slice(0, 3),
      tags: matchedTags.slice(0, 5)
    };
  }

  // Render search results
  function renderSearchResults(results) {
    const container = document.getElementById('search-results-content');
    if (!container) return;

    let html = '';

    if (results.publications.length > 0) {
      html += '<div class="p-3 border-b border-gray-100"><h3 class="font-semibold text-xs uppercase tracking-wide text-gray-500 mb-3">Publications</h3>';
      results.publications.forEach(pub => {
        html += `
          <a href="/publications/${slugify(pub.id)}" class="block p-2 hover:bg-gray-50 rounded-md transition-colors">
            <div class="font-medium text-sm leading-tight mb-1 text-gray-900">${pub.title}</div>
            <div class="text-xs text-gray-500">${pub.journal} â€¢ ${pub.year}</div>
          </a>
        `;
      });
      html += '</div>';
    }

    if (results.tags.length > 0) {
      html += '<div class="p-3"><h3 class="font-semibold text-xs uppercase tracking-wide text-gray-500 mb-3">Topics</h3>';
      results.tags.forEach(({ tag, publicationCount }) => {
        html += `
          <a href="/tags/${slugify(tag)}" class="block p-2 hover:bg-gray-50 rounded-md transition-colors">
            <div class="flex justify-between items-center">
              <span class="text-sm text-gray-900">${tag}</span>
              <span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full">${publicationCount}</span>
            </div>
          </a>
        `;
      });
      html += '</div>';
    }

    if (results.publications.length === 0 && results.tags.length === 0) {
      html = '<div class="p-4 text-sm text-gray-500 text-center">No results found</div>';
    }

    container.innerHTML = html;
  }

  // Initialize search functionality
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM loaded, initializing search...');
    await loadData();

    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    const searchButton = document.getElementById('search-button');
    const searchForm = searchInput?.closest('form');

    console.log('Search elements:', { searchInput, searchResults, searchButton, searchForm });
    console.log('Publications loaded:', publications.length);

    if (!searchInput || !searchResults || !searchButton) {
      console.error('Missing search elements');
      return;
    }

    // Test initial functionality
    if (publications.length === 0) {
      console.warn('No publications loaded - search functionality may be limited');
    }

    // Function to perform search navigation
    function performSearch() {
      const query = searchInput.value.trim();
      console.log('Performing search with query:', query);
      if (query) {
        const searchUrl = `/search?q=${encodeURIComponent(query)}`;
        console.log('Navigating to:', searchUrl);
        window.location.href = searchUrl;
      } else {
        console.log('Empty query, showing feedback');
        // Visual feedback for empty search
        searchInput.focus();
        searchInput.style.borderColor = '#ef4444';
        setTimeout(() => {
          searchInput.style.borderColor = '';
        }, 1000);
      }
    }

    let searchTimeout;

    // Search input handler
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      console.log('Search query:', query);

      clearTimeout(searchTimeout);

      // Show immediate feedback for short queries
      if (query.length === 1) {
        const container = document.getElementById('search-results-content');
        if (container) {
          container.innerHTML = '<div class="p-4 text-sm text-gray-500 text-center">Type at least 2 characters to search...</div>';
          searchResults.classList.remove('hidden');
        }
      }

      searchTimeout = setTimeout(() => {
        if (query.length >= 2) {
          console.log('Searching for:', query);
          const results = searchContent(query);
          console.log('Search results:', results);
          renderSearchResults(results);
          searchResults.classList.remove('hidden');
        } else if (query.length === 0) {
          searchResults.classList.add('hidden');
        }
      }, 200);
    });

    // Hide results when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-box-container')) {
        searchResults.classList.add('hidden');
      }
    });

    // Show results when focusing on input (if there's already a query)
    searchInput.addEventListener('focus', () => {
      if (searchInput.value.trim().length >= 2) {
        searchResults.classList.remove('hidden');
      }
    });

    // Handle form submit
    if (searchForm) {
      searchForm.addEventListener('submit', (e) => {
        e.preventDefault();
        console.log('Form submitted');
        performSearch();
      });
    }

    // Handle search button click
    searchButton.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('Search button clicked');
      performSearch();
    });

    // Handle Enter key
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        console.log('Enter key pressed');
        e.preventDefault();
        e.stopPropagation();
        performSearch();
      }
    });
  });
</script>

<style>
  .search-box-container {
    position: relative;
    width: 100%;
    max-width: 400px;
  }

  #search-results {
    max-height: 400px;
    overflow-y: auto;
  }

  #search-results::-webkit-scrollbar {
    width: 4px;
  }

  #search-results::-webkit-scrollbar-track {
    background: transparent;
  }

  #search-results::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 2px;
  }

  #search-results::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
  }
</style>