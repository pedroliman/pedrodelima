---
// SearchBox component for searching publications and tags
---

<div class="search-box-container">
  <div class="relative">
    <input
      type="text"
      id="search-input"
      placeholder="Search publications or topics..."
      class="w-full px-4 py-2 pr-10 border border-main/20 rounded-lg focus:outline-none focus:border-main/40 focus:ring-1 focus:ring-main/20"
      autocomplete="off"
    />
    <button
      id="search-button"
      class="absolute right-2 top-1/2 transform -translate-y-1/2 text-main/60 hover:text-main"
      type="button"
    >
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg>
    </button>
  </div>
  
  <!-- Search Results Dropdown -->
  <div 
    id="search-results" 
    class="absolute z-50 w-full mt-1 bg-white dark:bg-gray-800 border border-main/20 rounded-lg shadow-lg hidden"
  >
    <div id="search-results-content">
      <!-- Results will be populated by JavaScript -->
    </div>
  </div>
</div>

<script>
  let publications = [];
  let allTags = new Set();

  // Simple slugify function (copied from utils)
  function slugify(input) {
    if (!input) return '';
    var slug = input.toLowerCase().trim();
    slug = slug.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    slug = slug.replace(/[^a-z0-9\s-]/g, ' ').trim();
    slug = slug.replace(/[\s-]+/g, '-');
    return slug;
  }

  // Load publications data on page load
  async function loadData() {
    try {
      // We'll fetch the data from a JSON endpoint instead
      const response = await fetch('/api/publications.json');
      if (response.ok) {
        publications = await response.json();
        // Collect all unique tags
        publications.forEach(pub => {
          if (pub.tags) {
            pub.tags.forEach(tag => allTags.add(tag));
          }
        });
      }
    } catch (error) {
      console.error('Failed to load publications:', error);
    }
  }

  // Search function
  function searchContent(query) {
    if (!query || query.length < 2) {
      return { publications: [], tags: [] };
    }

    const queryLower = query.toLowerCase();
    const matchedPublications = [];
    const matchedTags = [];

    // Search publications
    publications.forEach(pub => {
      let score = 0;
      let reasons = [];

      // Title match (highest priority)
      if (pub.title.toLowerCase().includes(queryLower)) {
        score += 10;
        reasons.push('title');
      }

      // Abstract match
      if (pub.abstract && pub.abstract.toLowerCase().includes(queryLower)) {
        score += 5;
        reasons.push('abstract');
      }

      // Journal match
      if (pub.journal.toLowerCase().includes(queryLower)) {
        score += 3;
        reasons.push('journal');
      }

      // Authors match
      if (pub.authors.toLowerCase().includes(queryLower)) {
        score += 2;
        reasons.push('authors');
      }

      // Tags match
      if (pub.tags) {
        pub.tags.forEach(tag => {
          if (tag.toLowerCase().includes(queryLower)) {
            score += 4;
            reasons.push('tags');
          }
        });
      }

      if (score > 0) {
        matchedPublications.push({ ...pub, searchScore: score, matchReasons: reasons });
      }
    });

    // Search tags
    Array.from(allTags).forEach(tag => {
      if (tag.toLowerCase().includes(queryLower)) {
        const tagPublicationCount = publications.filter(pub => 
          pub.tags && pub.tags.includes(tag)
        ).length;
        matchedTags.push({ tag, publicationCount: tagPublicationCount });
      }
    });

    // Sort publications by search score (descending)
    matchedPublications.sort((a, b) => b.searchScore - a.searchScore);

    // Sort tags by publication count (descending)
    matchedTags.sort((a, b) => b.publicationCount - a.publicationCount);

    return {
      publications: matchedPublications.slice(0, 3),
      tags: matchedTags.slice(0, 5)
    };
  }

  // Render search results
  function renderSearchResults(results) {
    const container = document.getElementById('search-results-content');
    if (!container) return;

    let html = '';

    if (results.publications.length > 0) {
      html += '<div class="p-2 border-b border-main/10"><h3 class="font-medium text-sm text-main/80 mb-2">Publications</h3>';
      results.publications.forEach(pub => {
        html += `
          <a href="/publications/${slugify(pub.id)}" class="block p-2 hover:bg-main/5 rounded transition-colors">
            <div class="font-medium text-sm leading-tight mb-1">${pub.title}</div>
            <div class="text-xs text-main/60">${pub.journal} â€¢ ${pub.year}</div>
          </a>
        `;
      });
      html += '</div>';
    }

    if (results.tags.length > 0) {
      html += '<div class="p-2"><h3 class="font-medium text-sm text-main/80 mb-2">Topics</h3>';
      results.tags.forEach(({ tag, publicationCount }) => {
        html += `
          <a href="/tags/${slugify(tag)}" class="block p-2 hover:bg-main/5 rounded transition-colors">
            <div class="flex justify-between items-center">
              <span class="text-sm">${tag}</span>
              <span class="text-xs text-main/60">${publicationCount} publication${publicationCount !== 1 ? 's' : ''}</span>
            </div>
          </a>
        `;
      });
      html += '</div>';
    }

    if (results.publications.length === 0 && results.tags.length === 0) {
      html = '<div class="p-4 text-sm text-main/60 text-center">No results found</div>';
    }

    container.innerHTML = html;
  }

  // Initialize search functionality
  document.addEventListener('DOMContentLoaded', async () => {
    await loadData();
    
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    const searchButton = document.getElementById('search-button');
    
    if (!searchInput || !searchResults || !searchButton) return;

    let searchTimeout;

    // Search input handler
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        if (query.length >= 2) {
          const results = searchContent(query);
          renderSearchResults(results);
          searchResults.classList.remove('hidden');
        } else {
          searchResults.classList.add('hidden');
        }
      }, 300);
    });

    // Hide results when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-box-container')) {
        searchResults.classList.add('hidden');
      }
    });

    // Show results when focusing on input (if there's already a query)
    searchInput.addEventListener('focus', () => {
      if (searchInput.value.trim().length >= 2) {
        searchResults.classList.remove('hidden');
      }
    });

    // Handle search button click
    searchButton.addEventListener('click', () => {
      const query = searchInput.value.trim();
      if (query) {
        // Navigate to research page with search query (implement this later if needed)
        window.location.href = `/research?q=${encodeURIComponent(query)}`;
      }
    });

    // Handle Enter key
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchButton.click();
      }
    });
  });
</script>

<style>
  .search-box-container {
    position: relative;
    width: 100%;
    max-width: 400px;
  }

  #search-results {
    max-height: 400px;
    overflow-y: auto;
  }

  #search-results::-webkit-scrollbar {
    width: 4px;
  }

  #search-results::-webkit-scrollbar-track {
    background: transparent;
  }

  #search-results::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 2px;
  }

  #search-results::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
  }
</style>